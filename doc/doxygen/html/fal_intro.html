<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crazy Eddie&#39;s GUI System: Introduction and overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Crazy Eddie&#39;s GUI System
   &#160;<span id="projectnumber">${CEGUI_VERSION}</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('fal_intro.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction and overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="fal_whatis"></a>
What is the Falagard Skinning System?</h1>
<p>The Falagard skinning system for CEGUI consists partly of a set of enhancements to the CEGUI base library, and partly of a window renderer module called "CEGUICoreWindowRendererSet". Combined, these elements are intended to make it easier to create custom skins or 'looks' for CEGUI window and widget elements.</p>
<p>The Falagard system is designed to allow widget imagery specification, sub-widget layout, and default property initialisers to be specified via XML files rather than in C++ or scripted code (which, before now, was the only way to do these things).</p>
<p>The system is named "Falagard" after the forum name of the person who initially suggested the feature (as is the trend in all things CEGUI), although it was designed and implemented by the core CEGUI team.</p>
<p>The Falagard extensions are not limited to the 'looknfeel' XML files only; there are supporting elements within the core library, as well as extensions to the GUI scheme system to allow you to create what are essentially new widget types. This is achieved by mapping a named widget 'look' and a named window renderer to a named widget base type. I've probably just about lost you now, the best thing is to not worry about all these details for the time being!</p>
<p>Once your new type has been defined in a scheme and loaded, you can specify the name of that new type name when creating windows or widgets via the WindowManager singleton as you would for any other widget type. There are no additional issues to be considered when using a 'skinned' widget than when using one of the old 'programmed' widget types.</p>
<h1><a class="anchor" id="fal_intro_contents"></a>
Section Contents</h1>
<ul>
<li><a class="el" href="fal_intro.html#fal_unifiedsystem">The Unified Co-ordinate System</a></li>
<li><a class="el" href="fal_intro.html#fal_udim">The UDim type</a></li>
<li><a class="el" href="fal_intro.html#fal_uvector2">The UVector2 type</a></li>
<li><a class="el" href="fal_intro.html#fal_urect">The URect type</a></li>
<li><a class="el" href="fal_intro.html#fal_window_alignments">Window Alignments</a></li>
<li><a class="el" href="fal_intro.html#fal_schemes">Falagard in Schemes</a></li>
<li><a class="el" href="fal_intro.html#fal_conclusion">Conclusion</a></li>
</ul>
<h1><a class="anchor" id="fal_unifiedsystem"></a>
The Unified Co-ordinate System</h1>
<p>As part of the Falagard system, CEGUI has effectively replaced the old either/or approach to relative and absolute co-ordinates with a new 'unified' co-ordinate system. Using this new system, each co-ordinate can specify both a parent-relative and absolute-pixel component. Since most people baulk at the idea of this, I'll use examples to introduce these concepts.</p>
<h2><a class="anchor" id="fal_udim"></a>
UDim</h2>
<h3><a class="anchor" id="fal_udim_def"></a>
UDim Definition</h3>
<p>The basic building block of the unified system is the UDim. This type represents a single dimension of some kind, and is defined as: </p><div class="fragment"><div class="line">UDim(scale, offset)</div></div><!-- fragment --><p>where: </p><ul>
<li><code>'scale'</code> represents some proportion of the parent element, where the parent element is either some other Window or the total available display, and is usually a value between 0 and 1.0. The scale value corresponds to relative coordinates under the pre-unified system. </li>
<li><code>'offset'</code> represents an arbitrary number of pixels. For positional values, offset represents a pixel offset, for size values, offset represents a number of additional pixels (basically like a padding value). The offset value corresponds to absolute coordinates under the pre-unified system.</li>
</ul>
<p>Still confused? On to the examples!</p>
<h3><a class="anchor" id="fal_udim_examples"></a>
Simple UDim Examples</h3>
<h4><a class="anchor" id="fal_udim_example1"></a>
Example 1</h4>
<div class="fragment"><div class="line">UDim(0, 10)</div></div><!-- fragment --><p> Here we see a UDim with a scale of 0, and an offset of 10. This simply represents an absolute value of 10, if you used such a UDim to set a window width, then under the old system it's the equivalent of: </p><div class="fragment"><div class="line">myWindow-&gt;setWidth(Absolute, 10);</div></div><!-- fragment --><h4><a class="anchor" id="fal_udim_example2"></a>
Example 2</h4>
<div class="fragment"><div class="line">UDim(0.25f, 0)</div></div><!-- fragment --><p> Here we see a UDim with a scale of 0.25 and an offset of 0. This represents a simple relative co-ordinate. If you were to set the y position of a window using this UDim, then the window would be a quarter of the way down it's parent, and it's the same as the following under the old system: </p><div class="fragment"><div class="line">myWindow-&gt;setYPosition(Relative, 0.25f);</div></div><!-- fragment --><h4><a class="anchor" id="fal_udim_example3"></a>
Example 3</h4>
<div class="fragment"><div class="line">UDim(0.33f, -15)</div></div><!-- fragment --><p> Here we see the power of UDim. We have a scale of 0.33 and an offset of -15. If we used this as the height of a window, you would get a height that is approximately one third of the height of the window's parent, minus 15 pixels. There is no simple equivalent for this under the old system.</p>
<h3><a class="anchor" id="fal_udim_prop_fmt"></a>
UDim Property Format</h3>
<p>The format of a UDim to be used in the window property strings is as follows: </p><div class="fragment"><div class="line">{s,o}</div></div><!-- fragment --><p>where: </p><ul>
<li><code>'s'</code> is the scale value. </li>
<li><code>'o'</code> is the pixel offset.</li>
</ul>
<h2><a class="anchor" id="fal_uvector2"></a>
UVector2</h2>
<h3><a class="anchor" id="fal_uvector2_def"></a>
UVector2 Definition</h3>
<p>There is a UVector2 type which consists of two UDim elements; one for the x axis, and one for the y axis. Note that the UVector2 is used to specify both positional points and also sizes; that is, there is no such thing as USize to correspond to the CEGUI::Size type that used to be used for specifying a size.</p>
<p>The UVector2 is defined as: </p><div class="fragment"><div class="line">UVector2(x_udim, y_udim)</div></div><!-- fragment --><p> where: </p><ul>
<li><code>'x_udim'</code> is a UDim value that specifies the x co-ordinate or width. </li>
<li><code>'y_udim'</code> is a UDim value that specifies the y co-ordinate or height.</li>
</ul>
<h3><a class="anchor" id="fal_uvector2_examples"></a>
Simple UVector2 Examples</h3>
<h4><a class="anchor" id="fal_uvec2_example1"></a>
Example 1</h4>
<div class="fragment"><div class="line">UVector2( UDim(0, 25), UDim(0.2f, 12) )</div></div><!-- fragment --><p> The above example specifies a point that is 25 pixels along the x-axis and one fifth of the way down the parent window plus twelve pixels.</p>
<h4><a class="anchor" id="fal_uvec2_example2"></a>
Example 2</h4>
<div class="fragment"><div class="line">UVector2( UDim(1.0f, -25), UDim(1.0f, -25) )</div></div><!-- fragment --><p> This example, intended as a size for a window, would give the window the same width as its parent, minus 25 pixels, and the same height as its parent, minus 25 pixels.</p>
<h3><a class="anchor" id="fal_uvector2_prop_fmt"></a>
UVector2 Property Format</h3>
<p>The format of a UVector2 to be used in the window property strings is as follows: </p><div class="fragment"><div class="line">{{sx,ox},{sy,oy}}</div></div><!-- fragment --><p>where: </p><ul>
<li><code>'sx'</code> is the scale value for the x-axis </li>
<li><code>'ox'</code> is the pixel offset for the x-axis. </li>
<li><code>'sy'</code> is the scale value for the y-axis </li>
<li><code>'oy'</code> is the pixel offset for the y-axis.</li>
</ul>
<h2><a class="anchor" id="fal_urect"></a>
URect</h2>
<h3><a class="anchor" id="fal_urect_def"></a>
URect Definition</h3>
<p>The last of the Unified co-ordinate types is URect. The URect defines four sides of a rectangle using UDim elements. You generally access the URect as you would the normal 'Rect' type, except that each edge of the rectangle is represented by a UDim rather than a float, or any other type you may be used to seeing! </p><div class="fragment"><div class="line">URect(left_udim, top_udim, right_udim, bottom_udim)</div></div><!-- fragment --><p>where: </p><ul>
<li><code>'left_udim'</code> is a UDim defining the left edge. </li>
<li><code>'top_udim'</code> is a UDim defining the top edge. </li>
<li><code>'right_udim'</code> is a UDim defining the right edge. </li>
<li><code>'bottom_udim'</code> is a UDim defining the bottom edge.</li>
</ul>
<p>It is also possible to define a URect with two UVector2 objects; the first describes the top-left corner, and the second the bottom-right corner: </p><div class="fragment"><div class="line">URect(tl_uvec2, br_uvec2)</div></div><!-- fragment --><p>where: </p><ul>
<li><code>'tl_uvec2'</code> is a UVector2 that describes the top-left point of the rect area. </li>
<li><code>'br_uvec2'</code> is a UVector2 that describes the bottom-right point of the rect area. Don't confuse this with the size of the area.</li>
</ul>
<h3><a class="anchor" id="fal_urect_examples"></a>
Simple URect Example</h3>
<div class="fragment"><div class="line">URect( UDim(0, 25),</div><div class="line">       UDim(0, 25),</div><div class="line">       UDim(1.0f, -25),</div><div class="line">       UDim(1.0f, -25)</div><div class="line">     )</div></div><!-- fragment --><p>If we used the URect defined here to specify the area for a window, we would get a window that was 25 pixels smaller than its parent on each edge.</p>
<h3><a class="anchor" id="fal_urect_prop_fmt"></a>
URect Property format</h3>
<p>The format of a URect to be used in the window property strings is as follows: </p><div class="fragment"><div class="line">{{sl,ol},{st,ot},{sr,or},{sb,ob}}</div></div><!-- fragment --><p>where: </p><ul>
<li><code>'sl'</code> is the scale value for the left edge. </li>
<li><code>'ol'</code> is the pixel offset for the left edge. </li>
<li><code>'st'</code> is the scale value for the top edge. </li>
<li><code>'ot'</code> is the pixel offset for the top edge. </li>
<li><code>'sr'</code> is the scale value for the right edge. </li>
<li><code>'or'</code> is the pixel offset for the right edge. </li>
<li><code>'sb'</code> is the scale value for the bottom edge. </li>
<li><code>'ob'</code> is the pixel offset for the bottom edge.</li>
</ul>
<h1><a class="anchor" id="fal_window_alignments"></a>
Window Alignments</h1>
<p>The Falagard enhancements also include settings to specify alignments for windows. This gives the possibility to position child windows from the right edge, bottom edge and centre positions of their parents, as well as the previous left edge and top edge possibilities.</p>
<p>It is possible to set the alignment options in C++ code by using methods in the Window class, and also via the properties system which is used by XML layouts system.</p>
<h2><a class="anchor" id="fal_vert_alignments"></a>
Vertical Alignments</h2>
<p>To set the vertical alignment use the Window class member function: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> setVerticalAlignment(<span class="keyword">const</span> VerticalAlignment alignment);</div></div><!-- fragment --><p>This function takes one of the VerticalAlignment enumerated values as its input. The VerticalAlignment enumeration is defined as: </p><div class="fragment"><div class="line"><span class="keyword">enum</span> VerticalAlignment</div><div class="line">{</div><div class="line">    VA_TOP,</div><div class="line">    VA_CENTRE,</div><div class="line">    VA_BOTTOM</div><div class="line">};</div></div><!-- fragment --><p>Where: </p><ul>
<li><code>VA_TOP</code> specifies that y-axis positions specify an offset for a window's top edge from the top edge of it's parent window. </li>
<li><code>VA_CENTRE</code> specifies that y-axis positions specify an offset for a window's centre point from the centre point of it's parent window. </li>
<li><code>VA_BOTTOM</code> specifies that y-axis positions specify an offset for a window's bottom edge from the bottom edge of it's parent window.</li>
</ul>
<p>The window property to access the vertical alignment setting is: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;VerticalAlignment&quot;</span></div></div><!-- fragment --><p> This property takes a simple string as its value, which should be one of the following options: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;Top&quot;</span></div><div class="line"><span class="stringliteral">&quot;Centre&quot;</span></div><div class="line"><span class="stringliteral">&quot;Bottom&quot;</span></div></div><!-- fragment --><p>Where these setting values correspond to the similar values in the VerticalAlignment enumeration.</p>
<h2><a class="anchor" id="fal_horz_alignments"></a>
Horizontal Alignments</h2>
<p>To set the horizontal alignment use the Window class member function: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> setHorizontalAlignment(<span class="keyword">const</span> HorizontalAlignment alignment);</div></div><!-- fragment --><p>This function takes one of the HorizontalAlignment enumerated values as its input. The HorizontalAlignment enumeration is defined as: </p><div class="fragment"><div class="line"><span class="keyword">enum</span> HorizontalAlignment</div><div class="line">{</div><div class="line">    HA_LEFT,</div><div class="line">    HA_CENTRE,</div><div class="line">    HA_RIGHT</div><div class="line">};</div></div><!-- fragment --><p>Where: </p><ul>
<li><code>HA_LEFT</code> specifies that x-axis positions specify an offset for a window's left edge from the left edge of it's parent window. </li>
<li><code>HA_CENTRE</code> specifies that x-axis positions specify an offset for a window's centre point from the centre point of it's parent window. </li>
<li><code>HA_RIGHT</code> specifies that x-axis positions specify an offset for a window's right edge from the right edge of it's parent window.</li>
</ul>
<p>The window property to access the horizontal alignment setting is: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;HorizontalAlignment&quot;</span></div></div><!-- fragment --><p>This property takes a simple string as its value, which should be one of the following options: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;Left&quot;</span></div><div class="line"><span class="stringliteral">&quot;Centre&quot;</span></div><div class="line"><span class="stringliteral">&quot;Right&quot;</span></div></div><!-- fragment --><p>Where these setting values correspond to the similar values in the HorizontalAlignment enumeration.</p>
<h1><a class="anchor" id="fal_schemes"></a>
Falagard in Schemes</h1>
<p>The CEGUI scheme system is the means by which you to specify how the system is to load your XML skin definition files, known as 'looknfeel' files, and how these skins are to be mapped to window renderers and widget base classes to create new concrete widget types.</p>
<h2><a class="anchor" id="fal_wr_modules"></a>
The CEGUICoreWindowRendererSet module</h2>
<p>One of the main parts of the Falagard system is the window renderer module known as CEGUICoreWindowRendererSet (which will be named libCEGUICoreWindowRendererSet.so on linux style systems and CEGUICoreWindowRendererSet.dll on Win32 systems). This module contains a set of predefined window renderer classes that take actions to transform skinning data loaded from skin definition XML files into the rendering operations and layout adjustments required to output the widget visual representation to the display.</p>
<p>Before you can make use of the CEGUICoreWindowRendererSet module it must be loaded into the system. To achieve this, you will usually specify it in one of your scheme XML files so that it's available to the system. This can be done with a single line of XML in a scheme file, such as: </p><div class="fragment"><div class="line">&lt;WindowRendererSet Filename=<span class="stringliteral">&quot;CEGUICoreWindowRendererSet&quot;</span> /&gt;</div></div><!-- fragment --><p>Some users, having previously employed the WindowSet 'look' modules, may be used to specifying a list of widgets which are to be made available from the module, this is not required when loading a WindowRenderer module (actually, such lists of widgets are no longer needed for the old style 'look' modules either, as long as the module has been updated to provide the required entry point); by employing XML such as that shown above, the module will register all widget types it has available.</p>
<p>The key thing about the CEGUICoreWindowRendererSet module is that for each widget base type, it defines various required elements and states. These required items need to be defined within the widget look definitions of your looknfeel XML files; they enable the system to make use of your skin imagery and related data in a logical fashion. All of the required elements for each widget can be found in the reference sections <a class="el" href="fal_baseclass_ref.html">CEGUI Widget Base Type Requirements</a> and <a class="el" href="fal_wr_ref.html">Falagard Window Renderer Requirements</a>.</p>
<h2><a class="anchor" id="fal_looknfeel_elements"></a>
LookNFeel Elements</h2>
<p>The <code>&lt;LookNFeel&gt;</code> XML element for schemes is the means by which you will usually get CEGUI to load the XML 'looknfeel' files containing your widget skin definitions. It is possible to load these files manually via code, but it is expected that the majority of users will be using the scheme system. The LookNFeel element should appear after any Font or Imageset elements, but before any WindowSet elements.</p>
<p>The following is an example of how to use the LookNFeel element: </p><div class="fragment"><div class="line">&lt;LookNFeel Filename=<span class="stringliteral">&quot;FunkyWidgets.looknfeel&quot;</span> /&gt;</div></div><!-- fragment --><p>Here we can see a single 'Filename' attribute which specifies the name the file to be loaded.</p>
<p>It is acceptable to specify as many LookNFeel elements as is required. This allows you to configure your XML files in the way that best suits your application. This might mean that all skin definitions for all widget elements will go into a single file, it might mean that you have multiple files with a single widget skin definition in each, or it could be any place in between the two extremes - it's up to you.</p>
<h2><a class="anchor" id="fal_mappings"></a>
FalagardMapping Elements</h2>
<p>The CEGUI scheme system supports a <code>&lt;FalagardMapping&gt;</code> element that creates a new concrete window or widget type within the system. This is achieved by creating a named alias that ties together a base widget type, a window renderer type, and a named widget 'LookNFeel'. Here, 'LookNFeel' refers to an individual widget skin as opposed to an entire 'looknfeel' XML file. The base widget type will generally be one of the core system widgets provided by the CEGUI library, although any window type that has a concrete WindowFactory registered in the system is a candidate, which allows the system to be extended with custom widgets. The window renderer type will usually be the name of one of the window renderers registered when the CEGUICoreWindowRendererSet module was loaded, again this is not a requirement - the window renderer used could just as easily be one you have written yourself. The named 'LookNFeel' is what you specify in your XML looknfeel files (via WidgetLook elements).</p>
<p>An example mapping: </p><div class="fragment"><div class="line">&lt;FalagardMapping</div><div class="line">    WindowType=<span class="stringliteral">&quot;FunkyLook/Button&quot;</span></div><div class="line">    TargetType=<span class="stringliteral">&quot;CEGUI/PushButton&quot;</span></div><div class="line">    Renderer=<span class="stringliteral">&quot;Falagard/Button&quot;</span></div><div class="line">    LookNFeel=<span class="stringliteral">&quot;MyButtonSkin&quot;</span></div><div class="line">/&gt;</div></div><!-- fragment --><p>In this example, a new widget type named "FunkyLook/Button" is being created. The new widget is based upon the "CEGUI/PushButton" base type, uses the window renderer named "Falagard/Button" and applies the skin defined by the loaded WidgetLook named "MyButtonSkin". Once the scheme with this mapping has been loaded, you can then use the new type within the system: </p><div class="fragment"><div class="line"><span class="comment">// Get access to the main window manager</span></div><div class="line">CEGUI::WindowManager wMgr&amp; = CEGUI::WindowManager::getSingleton();</div><div class="line"></div><div class="line"><span class="comment">// Create a new widget</span></div><div class="line">Window* wnd = wMgr.createWindow(<span class="stringliteral">&quot;FunkyLook/Button&quot;</span>, <span class="stringliteral">&quot;myFunkyButton&quot;</span>);</div></div><!-- fragment --><p>Here we create an instance of the new widget, and name it "myFunkyButton". The widget can now be attached to other windows and generally used as you would any 'normal' widget.</p>
<h1><a class="anchor" id="fal_conclusion"></a>
Conclusion</h1>
<p>This concludes the overview of the new parts of the CEGUI system.</p>
<p>You have seen how the new unified coordinate system works, and how to make use of the new window alignment options.</p>
<p>You have also learned the basics of how to set up your scheme files to initialise the Falagard window renderer module, and how to map skins defined in XML files to the Falagard to create new widget types.</p>
<p>The next section of this document will introduce the XML format and elements used in the 'looknfeel' files. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="fal_man.html">Falagard skinning system for CEGUI</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
